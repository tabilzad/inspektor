package io.github.tabilzad.ktor.k2

import io.github.tabilzad.ktor.OpenApiSpecCollector
import io.github.tabilzad.ktor.PluginConfiguration
import io.github.tabilzad.ktor.model.PartialOpenApiSpec
import io.github.tabilzad.ktor.model.PartialSpecLocation
import io.github.tabilzad.ktor.output.PartialSpecConverter
import io.github.tabilzad.ktor.output.convertInternalToOpenSpec
import io.github.tabilzad.ktor.writeFreshTo
import kotlinx.serialization.json.Json
import org.jetbrains.kotlin.backend.common.extensions.IrGenerationExtension
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.ir.declarations.IrModuleFragment
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.impl.IrBlockImpl
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.fqNameWhenAvailable
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.ir.visitors.transformChildrenVoid
import java.io.File

/**
 * IR generation extension that performs three tasks:
 *
 * 1. **Write OpenAPI Specification**: Consumes all route/schema data collected during the FIR phase
 *    (by [SwaggerDeclarationChecker]) and writes it to a single OpenAPI spec file. This ensures
 *    all @GenerateOpenApi functions are processed before writing, and the output is fresh
 *    (no merge with stale data from previous compilations).
 *
 * 2. **Multi-module support**:
 *    - For contributor modules: writes a partial spec to META-INF/inspektor/openapi-partial.json
 *    - For aggregator modules: reads partial specs from configured paths and merges them with local routes
 *
 * 3. **Lower responds<T>() calls**: Removes calls to `responds<T>()` and `respondsNothing()`
 *    from the generated bytecode. These calls are only used for compile-time metadata extraction
 *    and should not incur any runtime overhead.
 *
 * This extension runs once per module, AFTER all FIR analysis is complete, making it the
 * ideal place to aggregate and write the collected OpenAPI data.
 */
internal class OpenApiIrGenerationExtension(
    private val configuration: CompilerConfiguration,
    private val config: PluginConfiguration
) : IrGenerationExtension {

    @OptIn(UnsafeDuringIrConstructionAPI::class)
    override fun generate(
        moduleFragment: IrModuleFragment,
        pluginContext: IrPluginContext
    ) {
        // 1. Write OpenAPI spec from collected data
        if (config.isEnabled) {
            writeOpenApiSpec()
        }

        // 2. Lower responds<T>() calls to no-ops
        lowerRespondsCalls(moduleFragment, pluginContext)
    }

    /**
     * Consumes all collected route/schema data and writes the OpenAPI specification.
     * This is called once per module, after all FIR analysis is complete.
     *
     * Behavior depends on module configuration:
     * - Contributor module: writes partial spec to resources for aggregation
     * - Aggregator module: merges partial specs from dependencies with local routes
     * - Standalone module: writes full spec directly (default behavior)
     */
    private fun writeOpenApiSpec() {
        val collected = OpenApiSpecCollector.consumeAll(configuration, config.filePath)

        // Merge all routes from different @GenerateOpenApi functions in this module
        val allRoutes = collected.flatMap { it.routes }

        // Merge all schemas, later entries override earlier ones with same key
        val allSchemas = collected
            .flatMap { it.schemas.entries }
            .associate { it.key to it.value }

        // Convert to OpenAPI spec
        val localSpec = if (allRoutes.isNotEmpty() || allSchemas.isNotEmpty()) {
            convertInternalToOpenSpec(
                routes = allRoutes,
                configuration = config,
                schemas = allSchemas
            )
        } else {
            null
        }

        when {
            // Contributor module: write partial spec to resources
            config.isContributor -> {
                val moduleId = config.moduleId
                if (localSpec != null && moduleId != null) {
                    writePartialSpec(localSpec, moduleId)
                }
            }

            // Aggregator module: merge partial specs from dependencies with local routes
            config.isAggregator -> {
                val partialSpecs = loadPartialSpecsFromPaths()
                val mergedSpec = PartialSpecConverter.mergePartialSpecs(partialSpecs, localSpec)
                mergedSpec.writeFreshTo(config)
            }

            // Standalone module: write full spec directly
            else -> {
                localSpec?.writeFreshTo(config)
            }
        }
    }

    /**
     * Writes a partial OpenAPI spec to the resources directory for multi-module aggregation.
     * The partial spec will be embedded in the JAR and discovered by aggregator modules.
     */
    private fun writePartialSpec(
        spec: io.github.tabilzad.ktor.output.OpenApiSpec,
        moduleId: String
    ) {
        val resourcesPath = config.resourcesPath ?: return

        val partialSpec = PartialSpecConverter.toPartialSpec(spec, moduleId)

        // Create directory structure: {resourcesPath}/META-INF/inspektor/
        val outputDir = File(resourcesPath, PartialSpecLocation.RESOURCE_PATH)
        outputDir.mkdirs()

        val outputFile = File(outputDir, PartialSpecLocation.FILE_NAME)
        val json = Json { prettyPrint = true }
        outputFile.writeText(json.encodeToString(PartialOpenApiSpec.serializer(), partialSpec))
    }

    /**
     * Loads partial OpenAPI specs from explicitly configured paths.
     * The Gradle plugin is responsible for collecting and passing the paths
     * to all contributor modules' partial spec files.
     */
    private fun loadPartialSpecsFromPaths(): List<PartialOpenApiSpec> {
        val paths = config.partialSpecPaths
        if (paths.isEmpty()) return emptyList()

        val partialSpecs = mutableListOf<PartialOpenApiSpec>()
        val json = Json { ignoreUnknownKeys = true }

        for (path in paths) {
            try {
                val file = File(path)
                if (file.exists() && file.isFile) {
                    val content = file.readText()
                    val partialSpec = json.decodeFromString(PartialOpenApiSpec.serializer(), content)
                    partialSpecs.add(partialSpec)
                }
            } catch (e: Exception) {
                // Log warning but continue with other paths
                println("Warning: Failed to load partial spec from $path: ${e.message}")
            }
        }

        return partialSpecs
    }

    /**
     * Removes calls to responds<T>() and respondsNothing() from bytecode.
     * These are compile-time only constructs for OpenAPI metadata.
     */
    @OptIn(UnsafeDuringIrConstructionAPI::class)
    private fun lowerRespondsCalls(
        moduleFragment: IrModuleFragment,
        pluginContext: IrPluginContext
    ) {
        moduleFragment.transformChildrenVoid(
            object : IrElementTransformerVoid() {
                override fun visitCall(expression: IrCall): IrExpression {
                    val call = super.visitCall(expression) as IrCall
                    val fqName = call.symbol.owner.fqNameWhenAvailable

                    // Replace responds<T>() and respondsNothing() with empty blocks
                    if (fqName == ClassIds.KTOR_RESPONDS_NO_OP ||
                        fqName == ClassIds.KTOR_RESPONDS_NOTHING_NO_OP
                    ) {
                        return IrBlockImpl(
                            call.startOffset,
                            call.endOffset,
                            pluginContext.irBuiltIns.unitType,
                            null,
                            emptyList()
                        )
                    }
                    return call
                }
            }
        )
    }
}
