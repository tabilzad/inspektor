package io.github.tabilzad.ktor.k2

import io.github.tabilzad.ktor.OpenApiSpecCollector
import io.github.tabilzad.ktor.PluginConfiguration
import io.github.tabilzad.ktor.output.convertInternalToOpenSpec
import io.github.tabilzad.ktor.writeFreshTo
import org.jetbrains.kotlin.backend.common.extensions.IrGenerationExtension
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.ir.declarations.IrModuleFragment
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.impl.IrBlockImpl
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.fqNameWhenAvailable
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.ir.visitors.transformChildrenVoid

/**
 * IR generation extension that performs two tasks:
 *
 * 1. **Write OpenAPI Specification**: Consumes all route/schema data collected during the FIR phase
 *    (by [SwaggerDeclarationChecker]) and writes it to a single OpenAPI spec file. This ensures
 *    all @GenerateOpenApi functions are processed before writing, and the output is fresh
 *    (no merge with stale data from previous compilations).
 *
 * 2. **Lower responds<T>() calls**: Removes calls to `responds<T>()` and `respondsNothing()`
 *    from the generated bytecode. These calls are only used for compile-time metadata extraction
 *    and should not incur any runtime overhead.
 *
 * This extension runs once per module, AFTER all FIR analysis is complete, making it the
 * ideal place to aggregate and write the collected OpenAPI data.
 */
internal class OpenApiIrGenerationExtension(
    private val configuration: CompilerConfiguration,
    private val config: PluginConfiguration
) : IrGenerationExtension {

    @OptIn(UnsafeDuringIrConstructionAPI::class)
    override fun generate(
        moduleFragment: IrModuleFragment,
        pluginContext: IrPluginContext
    ) {
        // 1. Write OpenAPI spec from collected data
        if (config.isEnabled) {
            writeOpenApiSpec()
        }

        // 2. Lower responds<T>() calls to no-ops
        lowerRespondsCalls(moduleFragment, pluginContext)
    }

    /**
     * Consumes all collected route/schema data and writes the OpenAPI specification.
     * This is called once per module, after all FIR analysis is complete.
     */
    private fun writeOpenApiSpec() {
        val collected = OpenApiSpecCollector.consumeAll(configuration, config.filePath)

        if (collected.isNotEmpty()) {
            // Merge all routes from different @GenerateOpenApi functions
            val allRoutes = collected.flatMap { it.routes }

            // Merge all schemas, later entries override earlier ones with same key
            val allSchemas = collected
                .flatMap { it.schemas.entries }
                .associate { it.key to it.value }

            // Convert to OpenAPI spec and write fresh (no merge with existing file)
            val spec = convertInternalToOpenSpec(
                routes = allRoutes,
                configuration = config,
                schemas = allSchemas
            )

            spec.writeFreshTo(config)
        }
    }

    /**
     * Removes calls to responds<T>() and respondsNothing() from bytecode.
     * These are compile-time only constructs for OpenAPI metadata.
     */
    @OptIn(UnsafeDuringIrConstructionAPI::class)
    private fun lowerRespondsCalls(
        moduleFragment: IrModuleFragment,
        pluginContext: IrPluginContext
    ) {
        moduleFragment.transformChildrenVoid(
            object : IrElementTransformerVoid() {
                override fun visitCall(expression: IrCall): IrExpression {
                    val call = super.visitCall(expression) as IrCall
                    val fqName = call.symbol.owner.fqNameWhenAvailable

                    // Replace responds<T>() and respondsNothing() with empty blocks
                    if (fqName == ClassIds.KTOR_RESPONDS_NO_OP ||
                        fqName == ClassIds.KTOR_RESPONDS_NOTHING_NO_OP
                    ) {
                        return IrBlockImpl(
                            call.startOffset,
                            call.endOffset,
                            pluginContext.irBuiltIns.unitType,
                            null,
                            emptyList()
                        )
                    }
                    return call
                }
            }
        )
    }
}
